// @flow


declare module "phantasy" {


	declare export class IO<A> {

		runIO: () => A;

		constructor(): void;

		map<B>(f: (a: A) => B): IO<B>;

		andThen<B>(next: (a: A) => IO<B>): IO<B>;

		static of<B>(val: B): IO<B>;

		static lift<T, U>(f: (t: T) => U): (t: IO<T>) => IO<U>;

		static lift2<T, U, V>(f: (t: T, u: U) => V): *;

	}

	declare class Just<A> {}

	declare class Nothing {}

	declare type MaybeData<A> = Just<A> | Nothing

	declare export class Maybe<A> {

		constructor(data: MaybeData<A>): void;

		cases<B>(patterns: { Just: (a: A) => B, Nothing: () => B }): B;

		isJust(): bool;

		isNothing(): bool;

		getOrElse(dflt: A): A;

		eq(other: Maybe<A>): bool;

		notEq(other: Maybe<A>): bool;

		map<B>(f: (a: A) => B): Maybe<B>;

		ap<B>(arg: Maybe<B>): Maybe<*>;

		andThen<B>(next: (a: A) => Maybe<B>): Maybe<B>;

		toString(): string;

		static of(a: ?A): Maybe<A>;

		static Just<B>(a: B): Maybe<B>;

		static Nothing: Maybe<any>;

		static lift<T, U>(f: (t: T) => U): MaybeFn<T, U>;

	}

	declare type Unary<A, B> = (a: A) => B
	declare class MaybeFn<A, B> extends Maybe<Unary<A, B>> {}

	declare export class Reader<E, A> {

		runReader: (e: E) => A;

		constructor(runReader: (e: E) => A): void;

		andThen<B>(next: (a: A) => Reader<E, B>): Reader<E, B>;

		static of<B>(val: B): Reader<any, B>;

		static Ask<F>(): Reader<F, F>;

		static Asks<F, B>(f: (f: F) => B): Reader<F, B>;

		static getProp<B, F: { [k: string]: B }>(prop: string): Reader<F, B>;

		static lift<B, C>(f: (a: B) => C): (ra: Reader<E, B>) => Reader<E, C>;

		static lift2<B, C, D>(f: (a: B, b: C) => D): *;

	}

	declare export class State<S, A> {

		runState: (s: S) => { state: S, value: A };

		constructor(runState: (s: S) => { state: S, value: A }): void;

		getState(initState: S): S;

		getValue(initState: S): A;

		map<B>(f: (a: A) => B): State<S, B>;

		andThen<B>(next: (a: A) => State<S, B>): State<S, B>;

		static join<T, B>(state: State<T, State<T, B>>): State<T, B>;

		static of<T>(val: T): State<T, T>;

		static Get<T>(): State<T, T>;

		static Put<T>(s: T): State<T, any>;

		static Modify<T>(f: (s: T) => T): State<T, any>;

	}

	declare type TaskExecutor<A, X> = (res: (a: A) => void, rej: (x: X) => void) => void

	declare export class Task<A, X> {

		runTask: TaskExecutor<A, X>;

		constructor(runTask: TaskExecutor<A, X>): void;

		map<B>(f: (a: A) => B): Task<B, X>;

		andThen<B>(next: (a: A) => Task<B, X>): Task<B, X>;

		handleError(handle: (x: X) => Task<A, *>): Task<A, *>;

		toMaybe(): Task<Maybe<A>, void>;

		static of<B>(a: B): Task<B, *>;

		static Success<B>(a: B): Task<B, *>;

		static Fail<Y>(x: Y): Task<*, Y>;

		static fromPromise<B>(promise: Promise<B>): Task<B, ?Error>;

		static fromPromiseFunc<B>(promiseFn: () => Promise<B>): Task<B, ?Error>;

		static fromCallback<B, Y>(fn: (cb: (e: Y, v: B) => void) => void): Task<B, Y>;

		static lift<T, U, X>(f: (t: T) => U): (tt: Task<T, X>) => Task<U, X>;

		static lift2<T, U, V, X>(f: (t: T, u: U) => V): *;

	}

	declare export class Writer<E, A> {

		data: { value: A, env: E[] };

		constructor(data: { value: A, env: E[] }): void;

		runWriter(): [E[], A];

		getEnv(): E[];

		getValue(): A;

		andThen<B>(next: (a: A) => Writer<E, B>): Writer<E, B>;

		static of<B>(val: B): Writer<any, B>;

		static Tell<F>(msg: F): Writer<F, any>;

	}

}
